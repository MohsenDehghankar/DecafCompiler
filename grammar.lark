start: decl+

decl : variabledec | funcdec | classdec | interfacedec | COMMENT

//------variable dec-----------
variabledec: variable";" -> variable_declare

variable : type IDENT 
        | type IDENT ","

type : "int"            -> int_variable_declaraion
        | "double"      -> double_variable_declaration
        | "bool"        -> bool_variable_declaration
        | "string"      -> string_variable_declaration
        | IDENT 
        | type "[]"

//--------function dec--------
funcdec : type IDENT "("formal")" stmtblock
        | "void" IDENT "("formal")" stmtblock

formal : variable*

stmtblock : "{"variabledec* stmt* COMMENT*"}"

stmt : [expr]";" | stmtblock | if | while 
    | for | return | print | "break" ";"

// -------expression---------
expr : assignment                       -> exp_calculated

assignment : lvalue "=" assignment       -> assignment_calculated
        | logical_expr                  -> pass_assignment

lvalue : logical_expr                 -> lvalue_calculated

// logical_expr_1 : logical_expr_1 "||" logical_expr_2 
//         | logical_expr_2

// logical_expr_2 : logical_expr_2 "&&" equlaity_expr 
//         | equlaity_expr

logical_expr : logical_expr "||" equlaity_expr
        | logical_expr "&&" equlaity_expr
        | equlaity_expr                                 -> pass_logic

equlaity_expr : equlaity_expr "==" compare_expr 
        | equlaity_expr "!=" compare_expr
        | compare_expr                                  -> pass_equality

compare_expr : compare_expr "<" math_expr_1 
        | compare_expr "<=" math_expr_1 
        | compare_expr ">" math_expr_1 
        | compare_expr ">=" math_expr_1 
        | math_expr_1                                   -> pass_compare

math_expr_1 : math_expr_1 "+" math_expr_2               -> add
        | math_expr_1 "-" math_expr_2                   -> sub
        | math_expr_2                                   -> pass_math_expr1

math_expr_2 : math_expr_2 "*" one_operand_expr          -> multiply
        | math_expr_2 "/" one_operand_expr              -> divide
        | math_expr_2 "%" one_operand_expr              -> mod
        | one_operand_expr                              -> pass_math_expr2

// from here to above, we have Registers or Variable or Immediate

one_operand_expr : "!"one_operand_expr  -> not_statement
        | "-"one_operand_expr   -> minus
        | paranthes             -> pass_one_operand_calculation  

// from here to above, we have Variable or Immediate

paranthes : "("expr")" 
        | high_proior           -> token_to_var       

high_proior : high_proior "." IDENT ("("actual?")")? 
        | high_proior"["expr"]" 
        | "new" IDENT
        | call                  -> call_action
        | constants             -> constant_operand

call : IDENT"("actual?")" 
        | "ReadLine()"          -> read_line
        | "NewArray("expr","type")" 
        | "ReadInteger()"   
        | IDENT                 -> identifier_in_expression    

constants : "this" 
        | constant              -> pass_constant

actual : actual","expr 
        | expr                  -> exp_to_actual

constant : HEX_NUMBER | NUMBER | BOOL | STRING_CONSTANT | "null"

//------special statements----------
if : "if" "(" expr ")" stmt ("else" stmt)?
while : "while" "(" expr ")" stmt
for : "for" "("[expr]";"expr";"[expr]")" stmt
return : "return" [expr] ";"
print : ("Print"|"print") "("actual")" ";" -> print

//---------class dec----------
classdec : "class" IDENT ["extends" IDENT] ["implements" (IDENT | IDENT",")+] "{"field*"}"
field : variabledec | funcdec

//--------interface dec--------
interfacedec : "interface" IDENT "{" prototype* "}"
prototype : type IDENT "(" formal ")" ";"
    | "void" IDENT "(" formal ")" ";"


STRING_CONSTANT : /"[^"^\n]*"/
COMMENT : "//" /[^\n]*/
        | "/*" /(.|\n)+/ "*/"
BOOL : "true" | "false"
IDENT : /[a-zA-Z]([\w]|[_]){0,30}/
HEX_NUMBER.2: /0x[\da-f]*/
READLINE.4: "ReadLine()"


%import common.ESCAPED_STRING
%import common._STRING_ESC_INNER
%import common.NUMBER
%import common.WS

%ignore WS
%ignore COMMENT