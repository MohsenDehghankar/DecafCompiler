start: decl+

decl : variabledec | funcdec | classdec | interfacedec | COMMENT

//------variable dec-----------
variabledec: variable";" -> variable_declare

variable : type IDENT 
        | type IDENT ","

type : "int"            -> int_variable_declaraion
        | "double"      -> double_variable_declaration
        | "bool"        -> bool_variable_declaration
        | "string"      -> string_variable_declaration
        | IDENT 
        | type "[]"

//--------function dec--------
funcdec : type IDENT "("formal")" stmtblock
        | "void" IDENT "("formal")" stmtblock

formal : variable*

stmtblock : "{" (variabledec|stmt|COMMENT)* "}" -> stmt_block

stmt : [expr]";"                                
        | stmtblock 
        | if 
        | while 
        | for 
        | return 
        | print 
        | "break" ";"        -> pass_stmt

// -------expression---------
expr_high_level : expr                                  -> end_of_expr                 // when the start and finish of expression is important (for, while)

expr : assignment                                       -> exp_calculated

assignment : lvalue "=" assignment                      -> assignment_calculated       // todo: assignment as assignment
        | logical_expr                                  -> pass_assignment

lvalue : logical_expr                                   -> lvalue_calculated

logical_expr : logical_expr "||" equlaity_expr          -> or_logic
        | logical_expr "&&" equlaity_expr               -> and_logic
        | equlaity_expr                                 -> pass_logic

equlaity_expr : equlaity_expr "==" compare_expr         -> equal
        | equlaity_expr "!=" compare_expr               -> not_equal
        | compare_expr                                  -> pass_equality

compare_expr : compare_expr "<" math_expr_1             -> less_than
        | compare_expr "<=" math_expr_1                 -> less_equal
        | compare_expr ">" math_expr_1                  -> grater_than
        | compare_expr ">=" math_expr_1                 -> grater_equal
        | math_expr_1                                   -> pass_compare

math_expr_1 : math_expr_1 "+" math_expr_2               -> add
        | math_expr_1 "-" math_expr_2                   -> sub
        | math_expr_2                                   -> pass_math_expr1

math_expr_2 : math_expr_2 "*" one_operand_expr          -> multiply
        | math_expr_2 "/" one_operand_expr              -> divide
        | math_expr_2 "%" one_operand_expr              -> mod
        | one_operand_expr                              -> pass_math_expr2

// from here to above, we have Registers or Variable or Immediate

one_operand_expr : "!"one_operand_expr  -> not_statement
        | "-"one_operand_expr   -> minus
        | paranthes             -> pass_one_operand_calculation  

// from here to above, we have Variable or Immediate

paranthes : "("expr")"          -> paranthes_action     // start of expression
        | high_proior           -> token_to_var         // start of expression 

// bellow this, no code is generatd yet.

high_proior : high_proior "." IDENT ("("actual?")")? 
        | high_proior"["expr"]" 
        | "new" IDENT
        | call                  -> call_action
        | constants             -> constant_operand     

call : IDENT"("actual?")" 
        | "ReadLine()"          -> read_line
        | "NewArray("expr","type")" 
        | "ReadInteger()"   
        | IDENT                 -> identifier_in_expression    

constants : "this" 
        | constant              -> pass_constant

actual : actual","expr 
        | expr                  -> exp_to_actual

constant : HEX_NUMBER 
        | NUMBER 
        | BOOL                  
        | STRING_CONSTANT 
        | "null"

//------special statements----------
if : if_stmt ("else" stmt)?     ->pass_if
if_stmt:  if_expr stmt -> if_stmt
if_expr : "if" "(" expr ")"     -> if_expr
while : "while" "(" expr ")" stmt
for : "for" "("exp_or_nothing";"expr_high_level";"exp_or_nothing")" stmt   -> _for
return : "return" [expr] ";"
print : ("Print"|"print") "("actual")" ";"      -> _print

//------helps finding which expr is empty---
exp_or_nothing : expr_high_level                -> pass_high_level_expr
                |                               -> false_expression

//---------class dec----------
classdec : "class" IDENT ["extends" IDENT] ["implements" (IDENT | IDENT",")+] "{"field*"}"
field : variabledec | funcdec

//--------interface dec--------
interfacedec : "interface" IDENT "{" prototype* "}"
prototype : type IDENT "(" formal ")" ";"
    | "void" IDENT "(" formal ")" ";"


STRING_CONSTANT : /"[^"^\n]*"/
COMMENT : "//" /[^\n]*/
        | "/*" /(.|\n)+/ "*/"
BOOL.2 : "true" | "false"
IDENT : /[a-zA-Z]([\w]|[_]){0,30}/
HEX_NUMBER.2: /0x[\da-f]*/
READLINE.4: "ReadLine()"
// EMPTY: ""


%import common.ESCAPED_STRING
%import common._STRING_ESC_INNER
%import common.NUMBER
%import common.WS

%ignore WS
%ignore COMMENT